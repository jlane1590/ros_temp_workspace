/*
 * inverse_kinematics.h
 *
 *  Created on: 31-Aug-2016
 *      Author: rohin
 */

#ifndef INCLUDE_INVERSE_KINEMATICS_H_
#define INCLUDE_INVERSE_KINEMATICS_H_

#include <rsptilt_ik_plugin/ik_base.h>
#include <vector>

#include <kdl/frames.hpp>
#include <kdl/jntarray.hpp>

//#include <rsptilt_kinematics/logger.h>

namespace rsptilt_kinematics
{

/**
 * An analytical IK solver for a five-dof arm
 */
class InverseKinematics : public ik_base::IKPlugin
{
public:
    /**
      * @param min_angles The minimum joint limits of the arm. The values are
      * provided as radians [rad].
      *
      * @param max_angles The maximum joint limits of the arm. The values are
      * provided as radians [rad].
      *
      * @param logger The injected logger can be used to receive internal log
      * messages. By default a null object is used which does not do anything
      * with received messages.
      */
     InverseKinematics(){}

     virtual ~InverseKinematics();

     bool initialize(
         const std::vector<double> &min_angles,
         const std::vector<double> &max_angles);

     /**
      * Calculate inverse position kinematics, from Cartesian coordinates to
      * joint coordinates.
      *
      * @param q_init A seed value for the inverse kinematics solver. It is
      * usually used in numerical solvers. In analytical solvers it can e.g.
      * contain the current joint configuration, so that the solver returns
      * the closest solution. However, this implementation returns all valid
      * solutions and thus does not use this argument. The values are
      * provided as radians [rad].
      *
      * @param p_in The Cartesian coordinates to solve for. The position
      * vector of the frame is provided as meters [m].
      *
      * @param q_out A list of all found and valid inverse kinematics
      * solutions. The values are provided as radians [rad].
      *
      * @return A value greater than zero if a solution was found or a value
      * less than zero if no solution was found.
      */

/*    int CartToJnt(const KDL::JntArray &q_init,
         const KDL::Frame &p_in,
         std::vector<KDL::JntArray> &q_out);
*/
     int ik(const KDL::Frame &frame, std::vector<double> &joints);

private:

     /**
      * Tell if a solution is inside of the joint limits.
      *
      * @param solution The solution that has been generated by the IK
      * solver.
      *
      * @return True if the solution is valid else false.
      */

     //bool isSolutionValid(const KDL::JntArray &solution) const;

     /**
      * The IK solver. It implements a best-effort approach to find a
      * solution: The five_dof arm with its five degrees of freedom is
      * deficient and therefore can only reach a limited set of arbitrary
      * six-dimensional Cartesian poses (within the workspace). This IK
      * solver finds solutions for arbitrary poses (within the workspace)
      * anyway. However, most solutions contain a certain error. The solution
      * is based on the inverse position kinematics of the Yasukawa Motoman
      * L-3 [1].
      *
      * [1] Craig, John J. Horton, M. J. (Ed.).
      *     Introduction to Robotics - Mechanics and Control.
      *     Prentice Hall, 2005.
      *
      * @param frame The Cartesian target frame for which the inverse
      * kinematics solves.
      *
      * @param offset_joint_1 Chooses if the first joint points towards or
      * away from the target.
      *
      * @param offset_joint_3 Chooses between elbow-up and elbow-down
      * solution
      *
      * @return If there is a solution a JntArray with five entries is
      * returned, else the JntArray is empty.
      */
     


//private:
     /**
      * Minimum joint limits.
      */
     std::vector<double> min_angles_;

     /**
      * Maximum joint limits.
      */
     std::vector<double> max_angles_;

     /**
      * The injected logger to send messages to the application which is
      * using this library.
      */
     //Logger &logger_;

     /**
      * Threshold when a number is near to +1 or -1. This is required to
      * prevent invalid arguments to acos.
      */
     static const double ALMOST_PLUS_ONE;
     static const double ALMOST_MINUS_ONE;

    /* radius of base joints; 0 index for even joints, 1 index for odd joints */
    static const double baseRadius[2];

    /* radius of platform joints; 0 index for even joints, 1 index for odd joints */
    static const double platformRadius[2];

    /* angle from x axis of base joints */
    static const double baseAngles[6];

    /* angle from x axis of platform joints */
    static const double platformAngles[6];

    /* angle from x axis of servo horn planes */
    static const double beta[6];

    static const double initialHeight;
    static const double hornLength;
    static const double legLength;
    static const double lambda; //angle of tilt of servos

    /* position of base strut ends in base (world) coordinate system */
    KDL::Vector b[6];

    KDL::Vector p[6];


}; // class end

} // namespace end

#endif /* INCLUDE_INVERSE_KINEMATICS_H_ */
